package lzss;

import java.util.ArrayList;
import java.util.List;

public class lzss {
	private static final int N = 512; // 缓冲区长度即字典区，一定要为2的次方，一般定义为4096，越长压缩比越高，但是由于设备RAM空间有限，大小为512
	private static final int F = 18; // 最大的输出长度
	private static final int THRESHOLD = 2; // 最小的数据长度要大于THRESHOLD，即=THRESHOLD+1
	private static final int NIL = N;

	private static int textsize = 0;
	private static int codesize = 0;
	private static int printcount = 0;

	private static byte[] enbuffer = new byte[N + F - 1]; // 压缩解压所要用到的缓冲区
	private static int match_position = 0;
	private static int match_length = 0;
	private static int[] lson = new int[N+1];
	private static int[] rson = new int[N+257];
	private static int[] dad = new int[N+1];
	
	/**
	 * 初始化二叉树 lson为左叶子节点，rson为右子节点，dad为父节点
	 */
	public static void InitTree() {
		int  i = 0;

		for (i = N + 1; i <= N + 256; i++)
		{
			rson[i] = NIL;
		}

		for (i = 0; i < N; i++)
		{
			dad[i] = NIL;
		}
	}
	
	/**
	 * 插入一个节点
	 * @param {Number} r 
	 */
	public static void InsertNode(int r) {
		int i=0, p=0, cmp=0;
		
		cmp = 1;
		p = N + 1 + Byte.toUnsignedInt(enbuffer[r]); // 这里需要按照无符号的方式去做加减计算
		rson[r] = lson[r] = NIL;
		match_length = 0;

		for (; ; )
		{		
			if (cmp >= 0)
			{
				if (rson[p] != NIL)
				{
					p = rson[p];
				}
				else
				{
					rson[p] = r;
					dad[r] = p;
					return;
				}
			}
			else
			{
				if (lson[p] != NIL)
				{
					p = lson[p];
				}
				else
				{
					lson[p] = r;
					dad[r] = p;
					return;
				}
			}

			for (i = 1; i < F; i++)
			{
				cmp = Byte.toUnsignedInt(enbuffer[r+i]) - Byte.toUnsignedInt(enbuffer[p + i]);
				if (cmp != 0)
				{
					break;
				}
			}

			if (i > match_length)
			{
				match_position = p;
				
				match_length = i;
				if (match_length >= F)
				{
					break;
				}
			}
		}

		dad[r] = dad[p];
		lson[r] = lson[p];
		rson[r] = rson[p];
		dad[lson[p]] = r;
		dad[rson[p]] = r;

		if (rson[dad[p]] == p)
		{
			rson[dad[p]] = r;
		}
		else
		{
			lson[dad[p]] = r;
		}

		dad[p] = NIL;
	}
	
	/**
	 * 删除一个节点
	 * @param {Number} p 
	 */
	public static void DeleteNode(int p) {
		int q = 0;

		if (dad[p] == NIL)
		{
			return;
		}

		if (rson[p] == NIL)
		{
			q = lson[p];
		}
		else if (lson[p] == NIL)
		{
			q = rson[p];
		}
		else
		{
			q = lson[p];

			if (rson[q] != NIL)
			{
				do
				{
					q = rson[q];
				}
				while (rson[q] != NIL);

				rson[dad[q]] = lson[q];
				dad[lson[q]] = dad[q];
				lson[q] = lson[p];
				dad[lson[p]] = q;
			}

			rson[q] = rson[p];
			dad[rson[p]] = q;
		}

		dad[q] = dad[p];

		if (rson[dad[p]] == p)
		{
			rson[dad[p]] = q;
		}
		else
		{
			lson[dad[p]] = q;
		}

		dad[p] = NIL;
	}
	
	/**
	 * 压缩一段数据
	 * @param {byte[]} data 
	 * 返回: 压缩后的数据
	 */
	public static byte[] encode(byte[] data) {
		int i, len, r, s, last_match_length, code_buf_ptr;
		byte c = 0, mask = 0;
		byte[] code_buf = new byte[17];
		int currEncodeIndex = 0; // 当前处理的数据位置
		int encodeDataLen = data.length; // 压缩数据的原始长度
		List<Byte> resultBuffer = new ArrayList<Byte>(); // 压缩结果输出

		textsize = 0;
		codesize = 0;
		printcount = 0;

		InitTree();

		code_buf[0] = 0;
		code_buf_ptr = mask = 1;
		s = 0;
		r = N - F;

		for (i = s; i < r; i++) {
			enbuffer[i] = 0;
		}

		for (len = 0; len < F && currEncodeIndex < encodeDataLen; len++, currEncodeIndex++) {
			enbuffer[r + len] = data[currEncodeIndex];
		}

		textsize = len;
		if (textsize == 0) {
			return null;
		}

		for (i = 1; i <= F; i++) {
			InsertNode(r - i);
		}

		InsertNode(r);

		do {
			if (match_length > len) {
				match_length = len;
			}

			if (match_length <= THRESHOLD) {
				match_length = 1;
				code_buf[0] |= mask;
				code_buf[code_buf_ptr++] = enbuffer[r];
			} else {
				code_buf[code_buf_ptr++] = (byte)(match_position & 0xFF);
				code_buf[code_buf_ptr++] = (byte)(((match_position >>> 4) & 0xf0) | (match_length - (THRESHOLD + 1))); // >>>为不带符号的右移
			}

			// 状态标志flag只有一个字节，8bit
			mask <<= 1;
			if ((mask & 0xFF) == 0) {
				for (i = 0; i < code_buf_ptr; i++) {
					resultBuffer.add(code_buf[i]);
				}

				codesize += code_buf_ptr;
				code_buf[0] = 0;
				code_buf_ptr = mask = 1;
			}

			last_match_length = match_length;

			for (i = 0; i < last_match_length && currEncodeIndex < encodeDataLen; i++, currEncodeIndex++) {
				DeleteNode(s);

				c = data[currEncodeIndex];

				enbuffer[s] = c;

				if (s < F - 1) {
					enbuffer[s + N] = c;
				}

				s = (s + 1) & (N - 1);
				r = (r + 1) & (N - 1);
				InsertNode(r);
			}

			textsize += i;
			if (textsize > printcount) {
				printcount += 1024;
			}

			while (i++ < last_match_length) {
				DeleteNode(s);
				s = (s + 1) & (N - 1);
				r = (r + 1) & (N - 1);
				if (--len > 0) {
					InsertNode(r);
				}
			}		
		} while (len > 0);

		if (code_buf_ptr > 1) {
			for (i = 0; i < code_buf_ptr; i++) {
				resultBuffer.add(code_buf[i]);
			}
			codesize += code_buf_ptr;
		}

		System.out.println("In : " + textsize);
		System.out.println("Out: " + codesize);
		System.out.println("Out/In: " + (double) codesize / textsize); // 压缩比

		byte[] result = new byte[resultBuffer.size()];
		for (i = 0; i < resultBuffer.size(); i++) {
			result[i] = (byte)resultBuffer.get(i).intValue();
		}
		
		return result;
	}
	
	public static void main(String[] args) {
		// 测试数据1-压缩之前的数据
		byte[] TEST_BUFFER1 = new byte[]{
				(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x7f,(byte)0x00,(byte)0x00,(byte)0x02,(byte)0x9c,(byte)0x01,(byte)0x00,
				(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x80,(byte)0x00,(byte)0x20,(byte)0x02,
				(byte)0xf0,(byte)0xc8,(byte)0x00,(byte)0x00,(byte)0x02,(byte)0x80,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x40,
				(byte)0x30,(byte)0x00,(byte)0x00,(byte)0x40,(byte)0x30,(byte)0x00,(byte)0x00,(byte)0x40,(byte)0x60,(byte)0x08,(byte)0x00,(byte)0x40,(byte)0x60,(byte)0x08,(byte)0x00,(byte)0x40,
				(byte)0x40,(byte)0x0c,(byte)0x3f,(byte)0xff,(byte)0xff,(byte)0xfc,(byte)0x1f,(byte)0xff,(byte)0xff,(byte)0xf8,(byte)0x10,(byte)0x41,(byte)0x00,(byte)0x02,(byte)0x00,(byte)0x41,
				(byte)0x00,(byte)0x02,(byte)0x00,(byte)0xc2,(byte)0x00,(byte)0x02,(byte)0x00,(byte)0x42,(byte)0x80,(byte)0x04,(byte)0x00,(byte)0x03,(byte)0x00,(byte)0x04,(byte)0x00,(byte)0x07,
				(byte)0x00,(byte)0x08,(byte)0x00,(byte)0x3d,(byte)0x00,(byte)0x18,(byte)0x1f,(byte)0xf1,(byte)0xc0,(byte)0x10,(byte)0x0f,(byte)0x81,(byte)0x30,(byte)0x30,(byte)0x08,(byte)0x01,
				(byte)0x0e,(byte)0x60,(byte)0x08,(byte)0x01,(byte)0x03,(byte)0xc0,(byte)0x08,(byte)0x01,(byte)0x01,(byte)0xc0,(byte)0x08,(byte)0x01,(byte)0x03,(byte)0xe0,(byte)0x08,(byte)0x01,
				(byte)0x0f,(byte)0x60,(byte)0x0f,(byte)0xf9,(byte)0x3c,(byte)0x30,(byte)0x0f,(byte)0xfd,(byte)0xf0,(byte)0x18,(byte)0x08,(byte)0x07,(byte)0xc0,(byte)0x18,(byte)0x00,(byte)0x05,
				(byte)0x00,(byte)0x1c,(byte)0x00,(byte)0x04,(byte)0x00,(byte)0x0c,(byte)0x00,(byte)0x0c,(byte)0x00,(byte)0x0c,(byte)0x00,(byte)0x0c,(byte)0x00,(byte)0x08,(byte)0x00,(byte)0x04,
				(byte)0x00,(byte)0x08,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x04,(byte)0x00,(byte)0x00,
				(byte)0x00,(byte)0x08,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x08,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x10,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x20,(byte)0x00,(byte)0x00,
				(byte)0x00,(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0x80,(byte)0x00,(byte)0x00,(byte)0x03,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x06,(byte)0x00,(byte)0x18,(byte)0x00,
				(byte)0x1c,(byte)0x00,(byte)0x18,(byte)0x00,(byte)0x38,(byte)0x00,(byte)0x08,(byte)0x00,(byte)0xe0,(byte)0x00,(byte)0x0c,(byte)0x07,(byte)0xc0,(byte)0x00,(byte)0x06,(byte)0x3f,
				(byte)0x00,(byte)0x00,(byte)0x03,(byte)0xf8,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0xf0,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x3e,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x07,
				(byte)0xc0,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0xf0,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x38,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x1e,(byte)0x00,(byte)0x00,(byte)0x00,
				(byte)0x07,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x03,(byte)0x80,(byte)0x00,(byte)0x00,(byte)0x01,(byte)0xc0,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0xe0,(byte)0x00,(byte)0x00,
				(byte)0x00,(byte)0x70,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x78,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x30,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x20,(byte)0x00,(byte)0x00,
				(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,
				(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x40,
				(byte)0x40,(byte)0x18,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x1c,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x2c,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x6c,(byte)0x00,(byte)0x40,
				(byte)0x40,(byte)0xc8,(byte)0x00,(byte)0x40,(byte)0x41,(byte)0x88,(byte)0x00,(byte)0x40,(byte)0x43,(byte)0x08,(byte)0x00,(byte)0x40,(byte)0x4e,(byte)0x08,(byte)0x00,(byte)0x40,
				(byte)0x5c,(byte)0x08,(byte)0x3f,(byte)0xff,(byte)0xf8,(byte)0x08,(byte)0x1f,(byte)0xff,(byte)0xd0,(byte)0x08,(byte)0x10,(byte)0x40,(byte)0x50,(byte)0x08,(byte)0x00,(byte)0x40,
				(byte)0x40,(byte)0x08,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x08,(byte)0x00,(byte)0x40,(byte)0x41,(byte)0x10,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x90,(byte)0x00,(byte)0x40,
				(byte)0x40,(byte)0xd0,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x70,(byte)0x00,(byte)0xc0,(byte)0x40,(byte)0x78,(byte)0x00,(byte)0xc0,(byte)0x40,(byte)0x3c,(byte)0x00,(byte)0x40,
				(byte)0xc0,(byte)0x1e,(byte)0x00,(byte)0x01,(byte)0xc0,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0xc0,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x00,
				(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,
				(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x40,
				(byte)0x40,(byte)0x18,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x1c,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x2c,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x6c,(byte)0x00,(byte)0x40,
				(byte)0x40,(byte)0xc8,(byte)0x00,(byte)0x40,(byte)0x41,(byte)0x88,(byte)0x00,(byte)0x40,(byte)0x43,(byte)0x08,(byte)0x00,(byte)0x40,(byte)0x4e,(byte)0x08,(byte)0x00,(byte)0x40,
				(byte)0x5c,(byte)0x08,(byte)0x3f,(byte)0xff,(byte)0xf8,(byte)0x08,(byte)0x1f,(byte)0xff,(byte)0xd0,(byte)0x08,(byte)0x10,(byte)0x40,(byte)0x50,(byte)0x08,(byte)0x00,(byte)0x40,
				(byte)0x40,(byte)0x08,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x08,(byte)0x00,(byte)0x40,(byte)0x41,(byte)0x10,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x90,(byte)0x00,(byte)0x40,
				(byte)0x40,(byte)0xd0,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x70,(byte)0x00,(byte)0xc0,(byte)0x40,(byte)0x78,(byte)0x00,(byte)0xc0,(byte)0x40,(byte)0x3c,(byte)0x00,(byte)0x40,
				(byte)0xc0,(byte)0x1e,(byte)0x00,(byte)0x01,(byte)0xc0,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0xc0,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x00,
				(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,
				(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x40,
				(byte)0x40,(byte)0x18,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x1c,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x2c,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x6c,(byte)0x00,(byte)0x40,
				(byte)0x40,(byte)0xc8,(byte)0x00,(byte)0x40,(byte)0x41,(byte)0x88,(byte)0x00,(byte)0x40,(byte)0x43,(byte)0x08,(byte)0x00,(byte)0x40,(byte)0x4e,(byte)0x08,(byte)0x00,(byte)0x40,
				(byte)0x5c,(byte)0x08,(byte)0x3f,(byte)0xff,(byte)0xf8,(byte)0x08,(byte)0x1f,(byte)0xff,(byte)0xd0,(byte)0x08,(byte)0x10,(byte)0x40,(byte)0x50,(byte)0x08,(byte)0x00,(byte)0x40,
				(byte)0x40,(byte)0x08,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x08,(byte)0x00,(byte)0x40,(byte)0x41,(byte)0x10,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x90,(byte)0x00,(byte)0x40,
				(byte)0x40,(byte)0xd0,(byte)0x00,(byte)0x40,(byte)0x40,(byte)0x70,(byte)0x00,(byte)0xc0,(byte)0x40,(byte)0x78,(byte)0x00,(byte)0xc0,(byte)0x40,(byte)0x3c,(byte)0x00,(byte)0x40,
				(byte)0xc0,(byte)0x1e,(byte)0x00,(byte)0x01,(byte)0xc0,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0xc0,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x40,(byte)0x00,(byte)0x00,(byte)0x00,
				(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,
		};
		
		// 测试数据1-压缩之后的数据
		byte[] TEST_RESULT_BUFFER1 = new byte[]{
				(byte)0xfe,(byte)0xed,(byte)0x15,(byte)0x01,(byte)0x7f,(byte)0x00,(byte)0x00,(byte)0x02,(byte)0x9c,(byte)0x01,(byte)0xfc,(byte)0xef,(byte)0x15,(byte)0xed,(byte)0x12,(byte)0x80,
				(byte)0x00,(byte)0x20,(byte)0x02,(byte)0xf0,(byte)0xc8,(byte)0xda,(byte)0xf8,(byte)0x10,(byte)0x80,(byte)0xed,(byte)0x16,(byte)0x40,(byte)0x30,(byte)0x1b,(byte)0x04,(byte)0x60,
				(byte)0x08,(byte)0xfe,(byte)0x24,(byte)0x03,(byte)0x40,(byte)0x0c,(byte)0x3f,(byte)0xff,(byte)0xff,(byte)0xfc,(byte)0x1f,(byte)0xff,(byte)0xff,(byte)0xff,(byte)0xf8,(byte)0x10,
				(byte)0x41,(byte)0x00,(byte)0x02,(byte)0x00,(byte)0xfa,(byte)0x39,(byte)0x01,(byte)0xc2,(byte)0x3a,(byte)0x00,(byte)0x42,(byte)0x80,(byte)0x04,(byte)0x00,(byte)0x03,(byte)0xff,
				(byte)0x00,(byte)0x04,(byte)0x00,(byte)0x07,(byte)0x00,(byte)0x08,(byte)0x00,(byte)0x3d,(byte)0xff,(byte)0x00,(byte)0x18,(byte)0x1f,(byte)0xf1,(byte)0xc0,(byte)0x10,(byte)0x0f,
				(byte)0x81,(byte)0xff,(byte)0x30,(byte)0x30,(byte)0x08,(byte)0x01,(byte)0x0e,(byte)0x60,(byte)0x08,(byte)0x01,(byte)0xdf,(byte)0x03,(byte)0xc0,(byte)0x08,(byte)0x01,(byte)0x01,
				(byte)0x63,(byte)0x00,(byte)0x03,(byte)0xe0,(byte)0xff,(byte)0x08,(byte)0x01,(byte)0x0f,(byte)0x60,(byte)0x0f,(byte)0xf9,(byte)0x3c,(byte)0x30,(byte)0xff,(byte)0x0f,(byte)0xfd,
				(byte)0xf0,(byte)0x18,(byte)0x08,(byte)0x07,(byte)0xc0,(byte)0x18,(byte)0xaf,(byte)0x00,(byte)0x05,(byte)0x00,(byte)0x1c,(byte)0x4a,(byte)0x00,(byte)0x0c,(byte)0x82,(byte)0x04,
				(byte)0x08,(byte)0x8a,(byte)0x4a,(byte)0x00,(byte)0x08,(byte)0xeb,(byte)0x18,(byte)0x04,(byte)0xed,(byte)0x10,(byte)0x8f,(byte)0x01,(byte)0x8f,(byte)0x01,(byte)0x10,(byte)0xa2,
				(byte)0xed,(byte)0x10,(byte)0x20,(byte)0x1a,(byte)0x01,(byte)0xf4,(byte)0x10,(byte)0x13,(byte)0x00,(byte)0x03,(byte)0xed,(byte)0x10,(byte)0x06,(byte)0xbb,(byte)0x00,(byte)0x18,
				(byte)0x7e,(byte)0x00,(byte)0x18,(byte)0x00,(byte)0x38,(byte)0x4e,(byte)0x00,(byte)0xe0,(byte)0x7f,(byte)0x00,(byte)0x0c,(byte)0x07,(byte)0xc0,(byte)0x00,(byte)0x06,(byte)0x3f,
				(byte)0xb4,(byte)0x00,(byte)0x15,(byte)0xf8,(byte)0xed,(byte)0x10,(byte)0xf0,(byte)0xed,(byte)0x10,(byte)0x3e,(byte)0xed,(byte)0x10,(byte)0xc9,(byte)0x00,(byte)0xd3,(byte)0x03,
				(byte)0xa5,(byte)0x38,(byte)0xed,(byte)0x10,(byte)0x1e,(byte)0xda,(byte)0x01,(byte)0xed,(byte)0x10,(byte)0x03,(byte)0x13,(byte)0x00,(byte)0x01,(byte)0x2a,(byte)0xde,(byte)0x01,
				(byte)0xe0,(byte)0xed,(byte)0x10,(byte)0x70,(byte)0xed,(byte)0x10,(byte)0x78,(byte)0xed,(byte)0x10,(byte)0x1e,(byte)0x00,(byte)0x50,(byte)0xaa,(byte)0x02,(byte)0xe7,(byte)0x1c,
				(byte)0xaf,(byte)0x00,(byte)0x1d,(byte)0x15,(byte)0x40,(byte)0x26,(byte)0x12,(byte)0x18,(byte)0x2c,(byte)0x00,(byte)0xd5,(byte)0x1c,(byte)0x2c,(byte)0x00,(byte)0x2c,(byte)0x2c,
				(byte)0x00,(byte)0x6c,(byte)0x2c,(byte)0x00,(byte)0xc8,(byte)0x00,(byte)0xbf,(byte)0x40,(byte)0x41,(byte)0x88,(byte)0x00,(byte)0x40,(byte)0x43,(byte)0x27,(byte)0x00,(byte)0x4e,
				(byte)0xfe,(byte)0x27,(byte)0x00,(byte)0x5c,(byte)0x08,(byte)0x3f,(byte)0xff,(byte)0xf8,(byte)0x08,(byte)0x1f,(byte)0x3f,(byte)0xff,(byte)0xd0,(byte)0x08,(byte)0x10,(byte)0x40,
				(byte)0x50,(byte)0x2b,(byte)0x01,(byte)0x5b,(byte)0x14,(byte)0xab,(byte)0x41,(byte)0x10,(byte)0x2c,(byte)0x00,(byte)0x90,(byte)0x2c,(byte)0x00,(byte)0xd0,(byte)0x2c,(byte)0x00,
				(byte)0x70,(byte)0xef,(byte)0x00,(byte)0xc0,(byte)0x40,(byte)0x78,(byte)0x74,(byte)0x10,(byte)0x3c,(byte)0x00,(byte)0x40,(byte)0x03,(byte)0xc0,(byte)0x1e,(byte)0xf5,(byte)0x03,
				(byte)0xde,(byte)0x01,(byte)0x1e,(byte)0x11,(byte)0x0e,(byte)0x1f,(byte)0x20,(byte)0x1f,(byte)0x32,(byte)0x1f,(byte)0x00,(byte)0x44,(byte)0x1f,(byte)0x56,(byte)0x1f,(byte)0x68,
				(byte)0x1f,(byte)0x7a,(byte)0x1f,(byte)0x0b,(byte)0x0f,(byte)0x9e,(byte)0x1f,(byte)0xb0,(byte)0x1f,(byte)0xc2,(byte)0x1f,(byte)0x00,(byte)0xd4,(byte)0x1f,(byte)0xe6,(byte)0x1f,
				(byte)0xf8,(byte)0x1f,(byte)0x0a,(byte)0x07,
		};
		
		// 测试数据2-压缩之前的数据
	    byte[] TEST_BUFFER2 = new byte[]{1,2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,5,20,8,10};
		// 测试数据2-压缩之后的数据
		byte[] TEST_RESULT_BUFFER2 = new byte[]{(byte)239,1,2,3,4,(byte)239,25,5,20,8,1,10};
		
		System.out.println("encode start!");
		
		// 两组数据都要测试通过
		byte[] resultByteArr = encode(TEST_BUFFER1);
			
		System.out.println("结果:");
		for (int i=0; i<resultByteArr.length; i++) {
			System.out.print(String.format("0x%02x,", resultByteArr[i]));
		}
		System.out.println();
    }
}
